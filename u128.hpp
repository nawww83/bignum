/**
 * @author nawww83@gmail.com
 * @brief Класс для арифметики 128-битных беззнаковых целых чисел.
 */

#pragma once

#include <cstdint>   // uint64_t
#include <cassert>   // assert
#include <string>    // std::string
#include <utility>   // std::exchange
#include <algorithm> // std::min, std::max
#include <tuple>     // std::pair, std::tie
#include "ulow.hpp"  // low64::ULOW
#include "defines.h"

#if defined(_MSC_VER) && (_MSC_VER >= 1920) && defined(_M_X64)
#define USE_MSVC_INTRINSICS_DIVISION
#endif

#if defined(_MSC_VER) && defined(_M_X64)
#define USE_MSVC_INTRINSICS
#endif

#ifdef USE_MSVC_INTRINSICS_DIVISION
#include <immintrin.h>
#endif

#ifdef USE_MSVC_INTRINSICS
#include <intrin.h>
#pragma intrinsic(_umul128)
#endif

namespace bignum::generic
{
    /**
     * @brief Вычисляет 2^W / x: частное Q и остаток R. Здесь W - битовая ширина числа U.
     */
    template <class U>
    inline std::pair<U, U> reciprocal_and_extend(U x)
    {
        assert(x != 0);
        const auto x_old = x;
        const auto i = x.countl_zero();
        x <<= i;
        x = -x;
        auto [Q, R] = i > 0 ? x / x_old : std::make_pair(x < x_old ? 0 : 1, x < x_old ? x : 0);
        Q += (U{1} << i);
        return {Q, R};
    }

    /**
     * @brief r = (r + delta) mod m
     * Возвращает 1, если остаток при сложении был больше или равен модулю m; иначе возвращает ноль.
     * @param r_rec = 2^W mod m.
     */
    template <class U>
    inline U smart_remainder_adder(U &r, const U &delta, const U &m, const U &r_rec)
    {
        assert(m != 0);
        const auto &delta_m = delta % m;
        const U &summ = r + delta_m;
        const bool overflow = summ < std::min(r, delta_m);
        r = summ + (overflow ? r_rec : 0ull);
        std::tie(std::ignore, r) = r / m;
        return overflow ? 1ull : (summ >= m ? 1ull : 0ull);
    }
}

namespace bignum::u128
{
    /**
     *
     */
    using u64 = uint64_t;

    /**
     * @brief Тип половинки числа.
     */
    using ULOW = low64::ULOW;

    /**
     * Класс для арифметики 128-битных беззнаковых целых чисел, основанный на половинчатом представлении числа.
     */
    class U128
    {
    public:
        /**
         * @brief Конструктор по умолчанию.
         */
        explicit constexpr U128() = default;

        /**
         * @brief Конструктор с параметром.
         */
        constexpr U128(u64 low) : mLow{low}
        {
            ;
        }

        /**
         * @brief Конструктор с параметром.
         */
        constexpr U128(ULOW low) : mLow{low}
        {
            ;
        }

        /**
         * @brief Конструктор с параметрами.
         */
        constexpr U128(u64 low, u64 high) : mLow{low}, mHigh{high}
        {
            ;
        }

        /**
         * @brief Конструктор с параметрами.
         */
        constexpr U128(ULOW low, ULOW high) : mLow{low}, mHigh{high}
        {
            ;
        }

        constexpr U128(const U128 &other) = default;

        constexpr U128(U128 &&other) = default;

        constexpr U128 &operator=(const U128 &other) = default;

        /**
         * @brief Оператор равно.
         */
        bool operator==(const U128 &other) const
        {
            return mLow == other.mLow && mHigh == other.mHigh;
        }

        /**
         * @brief Оператор сравнения.
         */
        std::partial_ordering operator<=>(const U128 &other) const
        {
            auto high_cmp = mHigh <=> other.mHigh;
            return high_cmp != 0 ? high_cmp : mLow <=> other.mLow;
        }

        /**
         * @brief Оператор сдвига влево. При больших сдвигах дает ноль.
         */
        U128 operator<<(uint32_t shift) const
        {
            if (shift >= 128u)
                return 0;
            U128 result = *this;
            int ishift = shift;
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_value = (static_cast<unsigned __int128>(result.mHigh()) << 64) | result.mLow();
            u128_value <<= ishift;
            // Преобразование результата обратно в структуру
            return {static_cast<u64>(u128_value & 0xFFFFFFFFFFFFFFFFULL), static_cast<u64>(u128_value >> 64)};
#else
            ULOW L{0};
            const bool change_L = ishift < 64 && ishift > 0;
            const bool change_ishift = ishift >= 64;
            L = change_L ? result.mLow >> (64 - ishift) : L;
            result.mHigh = change_ishift ? std::exchange(result.mLow, 0) : result.mHigh;
            ishift -= change_ishift ? 64 : 0;
            result.mLow <<= ishift;
            result.mHigh <<= ishift;
            result.mHigh |= L;
            return result;
#endif
        }

        /**
         * @brief Оператор сдвига влево.
         */
        U128 &operator<<=(uint32_t shift)
        {
            *this = *this << shift;
            return *this;
        }

        /**
         * @brief Оператор сдвига вправо. При больших сдвигах дает ноль.
         */
        U128 operator>>(uint32_t shift) const
        {
            if (shift >= 128u)
                return 0;
            U128 result = *this;
            int ishift = shift;
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_value = (static_cast<unsigned __int128>(result.mHigh()) << 64) | result.mLow();
            u128_value >>= ishift;
            // Преобразование результата обратно в структуру
            return {static_cast<u64>(u128_value & 0xFFFFFFFFFFFFFFFFULL), static_cast<u64>(u128_value >> 64)};
#else
            if (ishift < 64)
            {
                ULOW mask{ULOW::get_max_value()};
                mask <<= ishift;
                mask = ~mask;
                const auto &H = result.mHigh & mask;
                result.mLow >>= ishift;
                result.mHigh >>= ishift;
                result.mLow |= ishift == 0 ? H : H << (64 - ishift);
            }
            else
            {
                result.mLow = std::exchange(result.mHigh, 0);
                result.mLow >>= (ishift - 64);
            }
            return result;
#endif
        }

        /**
         * @brief Оператор сдвига вправо.
         */
        U128 &operator>>=(uint32_t shift)
        {
            *this = *this >> shift;
            return *this;
        }

        /**
         * @brief Оператор побитового И.
         */
        U128 operator&(const U128 &mask) const
        {
            U128 result = *this;
            result.mLow &= mask.mLow;
            result.mHigh &= mask.mHigh;
            return result;
        }

        /**
         * @brief Оператор побитового И.
         */
        U128 &operator&=(const U128 &mask)
        {
            *this = *this & mask;
            return *this;
        }

        /**
         * @brief Оператор побитового ИЛИ.
         */
        U128 operator|(const U128 &mask) const
        {
            U128 result = *this;
            result.mLow |= mask.mLow;
            result.mHigh |= mask.mHigh;
            return result;
        }

        /**
         * @brief Оператор побитового ИЛИ.
         */
        U128 &operator|=(const U128 &mask)
        {
            *this = *this | mask;
            return *this;
        }

        /**
         * @brief Оператор исключающего ИЛИ.
         */
        U128 operator^(const U128 &mask) const
        {
            U128 result = *this;
            result.mLow ^= mask.mLow;
            result.mHigh ^= mask.mHigh;
            return result;
        }

        /**
         * @brief Оператор исключающего ИЛИ.
         */
        U128 &operator^=(const U128 &mask)
        {
            *this = *this ^ mask;
            return *this;
        }

        /**
         * @brief Оператор инверсии битов.
         */
        U128 operator~() const
        {
            U128 result = *this;
            result.mLow = ~result.mLow;
            result.mHigh = ~result.mHigh;
            return result;
        }

        /**
         * @brief Оператор суммирования.
         */
        U128 operator+(const U128 &Y) const
        {
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_X = (static_cast<unsigned __int128>(mHigh()) << 64) | mLow();
            unsigned __int128 u128_Y = (static_cast<unsigned __int128>(Y.mHigh()) << 64) | Y.mLow();
            u128_X += u128_Y;
            // Преобразование результата обратно в структуру
            return {static_cast<u64>(u128_X & 0xFFFFFFFFFFFFFFFFULL), static_cast<u64>(u128_X >> 64)};
#else
            const U128 &X = *this;
            U128 result{X.mLow + Y.mLow, X.mHigh + Y.mHigh};
            const auto &carry = ULOW{result.mLow < std::min(X.mLow, Y.mLow) ? 1ull : 0ull};
            result.mHigh += carry;
            return result;
#endif
        }

        /**
         * @brief Оператор суммирования.
         */
        U128 &operator+=(const U128 &Y)
        {
            *this = *this + Y;
            return *this;
        }

        /**
         * @brief Оператор вычитания.
         */
        U128 operator-(const U128 &Y) const
        {
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_X = (static_cast<unsigned __int128>(mHigh()) << 64) | mLow();
            unsigned __int128 u128_Y = (static_cast<unsigned __int128>(Y.mHigh()) << 64) | Y.mLow();
            u128_X -= u128_Y;
            // Преобразование результата обратно в структуру
            return {static_cast<u64>(u128_X & 0xFFFFFFFFFFFFFFFFULL), static_cast<u64>(u128_X >> 64)};
#else
            const U128 &X = *this;
            if (X >= Y)
                return subtract_if_lhs_more(X, Y);
            return subtract_if_lhs_more(U128::get_max_value(), Y) + 1 + X;
#endif
        }

        /**
         * @brief Оператор вычитания.
         */
        U128 &operator-=(const U128 &Y)
        {
            *this = *this - Y;
            return *this;
        }

        /**
         * @brief Оператор минус.
         */
        U128 operator-() const
        {
            return U128{0} - *this;
        }

        /**
         * @brief Инкремент числа.
         * @return Число + 1.
         */
        U128 &inc()
        {
            *this = *this + U128{1};
            return *this;
        }

        /**
         * @brief Декремент числа.
         * @return Число - 1.
         */
        U128 &dec()
        {
            *this = *this - U128{1};
            return *this;
        }

        /**
         * @brief Оператор умножения.
         */
        U128 operator*(const U128 &Y) const
        {
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_X = (static_cast<unsigned __int128>(mHigh()) << 64) | mLow();
            unsigned __int128 u128_Y = (static_cast<unsigned __int128>(Y.mHigh()) << 64) | Y.mLow();
            u128_X *= u128_Y;
            // Преобразование результата обратно в структуру
            return {static_cast<u64>(u128_X & 0xFFFFFFFFFFFFFFFFULL), static_cast<u64>(u128_X >> 64)};
#else
            // x*y = (a + w*b)(c + w*d) = ac + w*(ad + bc) + w*w*bd = (ac + w*(ad + bc)) mod 2^128;
            const U128 &X = *this;
            const U128 &ac = mult_ext(X.low(), Y.low());
            const U128 &ad = mult_ext(X.low(), Y.high());
            const U128 &bc = (X != Y) ? mult_ext(X.high(), Y.low()) : ad;
            U128 result{ad + bc};
            result <<= 64;
            result += ac;
            return result;
#endif
        }

        /**
         * @brief Оператор умножения.
         */
        U128 &operator*=(const U128 &Y)
        {
            *this = *this * Y;
            return *this;
        }

        /**
         * @brief Половинчатый оператор умножения.
         */
        U128 operator*(const ULOW &Y) const
        {
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_X = (static_cast<unsigned __int128>(mHigh()) << 64) | mLow();
            unsigned __int128 u128_Y = Y();
            u128_X *= u128_Y;
            // Преобразование результата обратно в структуру
            return {static_cast<u64>(u128_X & 0xFFFFFFFFFFFFFFFFULL), static_cast<u64>(u128_X >> 64)};
#else
            const U128 &X = *this;
            // x*y = (a + w*b)(c + w*0) = ac + w*(0 + bc) = (ac + w*bc) mod 2^128;
            return (U128{mult_ext(X.high(), Y)} << 64) + mult_ext(X.low(), Y);
#endif
        }

        /**
         * @brief Половинчатый оператор умножения.
         */
        U128 &operator*=(const ULOW &Y)
        {
            *this = *this * Y;
            return *this;
        }

        /**
         * @brief Оператор умножения. Позволяет перемножать "узкие" числа, расположенные слева от "широкого" числа.
         */
        template <typename T>
        T operator*(const T &rhs) const
        {
            T result = rhs * *this;
            return result;
        }

        /**
         * @brief
         */
        template <typename T>
        T &operator*=(const T &) = delete;

        /**
         * @brief Оператор деления.
         * @return Частное от деления и остаток.
         */
        std::pair<U128, U128> operator/(const U128 &other) const
        {
            assert(other != 0);
            U128 X = *this;
            const auto &Y = other;
            U128 Q{0};
#if defined(__SIZEOF_INT128__) || defined(USE_MSVC_INTRINSICS_DIVISION)
            U128 R;
            Q = divide_u128<true, true>(X, Y, &R);
            return {Q, R};
#else
            auto div_helper = [&X, &Y, &Q]() -> void
            {
                if (X < Y)
                    return;
                U128 Q_sc{1};
                auto Y_sc{Y};
                const int n_bits = X.bit_length() - Y.bit_length() - 1;
                if (n_bits > 0)
                {
                    Y_sc <<= n_bits;
                    Q_sc <<= n_bits;
                }
                if (Y_sc <= (X - Y_sc)) // use the subtraction due to possible overflow.
                {
                    Y_sc <<= 1;
                    Q_sc <<= 1;
                }
                Q += Q_sc;
                X -= Y_sc;
                return;
            };
            for (; X >= Y;)
            {
                div_helper();
            }
            return {Q, X};
#endif
        }

        /**
         * @brief
         */
        std::pair<U128, U128> operator/=(const U128 &Y)
        {
            U128 remainder;
            std::tie(*this, remainder) = *this / Y;
            return std::make_pair(*this, remainder);
        }

        U128 operator%(const U128 &other) const
        {
#if defined(__SIZEOF_INT128__)
            U128 R;
            divide_u128<false, true>(*this, other, &R);
            return R;
#else
            const auto &[_, R] = *this / other;
            return R;
#endif
        }

        /**
         * @brief
         */
        U128 &operator%=(const U128 &Y)
        {
            *this = *this % Y;
            return *this;
        }

        /**
         * @brief Нижняя половина числа.
         */
        ULOW low() const
        {
            return mLow;
        }

        /**
         * @brief Верхняя половина числа.
         */
        ULOW high() const
        {
            return mHigh;
        }

        /**
         * @brief Количество битов, требуемое для представления числа.
         */
        int bit_length() const
        {
            return 128 - countl_zero();
        }

        /**
         * @brief Количество непрерывно идущих нулей битового представления числа, начиная с самого старшего бита.
         */
        int countl_zero() const
        {
            return mHigh == 0 ? 64 + mLow.countl_zero() : mHigh.countl_zero();
        }

        /**
         * @brief Получить максимальное значение 128-битного числа.
         */
        static constexpr U128 get_max_value()
        {
#if defined(__SIZEOF_INT128__)
            unsigned __int128 max_val = 0;
            max_val -= 1;
            return U128{static_cast<u64>(max_val & 0xFFFFFFFFFFFFFFFFULL), static_cast<u64>(max_val >> 64)};
#else
            return U128{ULOW::get_max_value(), ULOW::get_max_value()};
#endif
        }

        /**
         * @brief Умножение двух 64-битных чисел с расширением до 128-битного числа.
         * @details Авторский алгоритм умножения. Обобщается на любую разрядность.
         */
        static U128 mult_ext(ULOW x, ULOW y)
        {
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_x = x();
            unsigned __int128 u128_y = y();
            auto z = u128_x * u128_y;
            return U128{static_cast<u64>(z & 0xFFFFFFFFFFFFFFFFULL), static_cast<u64>(z >> 64)};
#elif defined(USE_MSVC_INTRINSICS)
            unsigned __int64 c, d;
            d = _umul128(x(), y(), &c);
            return U128{d, c};
#else
            constexpr int QUORTER_WIDTH = 32; // Четверть ширины 128-битного числа.
            constexpr ULOW MASK = (ULOW{1}() << QUORTER_WIDTH) - 1;
            const ULOW x_low = x & MASK;
            const ULOW y_low = y & MASK;
            const ULOW x_high = x >> QUORTER_WIDTH;
            const ULOW y_high = y >> QUORTER_WIDTH;
            const ULOW t1 = x_low * y_low;
            const ULOW t = t1 >> QUORTER_WIDTH;
            const ULOW t21 = x_low * y_high;
            const ULOW q = t21 >> QUORTER_WIDTH;
            const ULOW p = t21 & MASK;
            const ULOW t22 = x_high * y_low;
            const ULOW s = t22 >> QUORTER_WIDTH;
            const ULOW r = t22 & MASK;
            const ULOW t3 = x_high * y_high;
            U128 result{t1};
            const ULOW div = (q + s) + ((p + r + t) >> QUORTER_WIDTH);
            const auto p1 = t21 << QUORTER_WIDTH;
            const auto p2 = t22 << QUORTER_WIDTH;
            const ULOW mod = p1 + p2;
            result.mLow += mod;
            result.mHigh += div;
            result.mHigh += t3;
            return result;
#endif
        }

        /**
         * @brief Возведение в квадрат 64-битного числа с расширением до 128-битного числа.
         */
        static U128 square_ext(ULOW x)
        {
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_x = x();
            auto z = u128_x * u128_x;
            return U128{static_cast<u64>(z & 0xFFFFFFFFFFFFFFFFULL), static_cast<u64>(z >> 64)};
#elif defined(USE_MSVC_INTRINSICS)
            unsigned __int64 c, d;
            d = _umul128(x(), x(), &c);
            return U128{d, c};
#else
            constexpr int QUORTER_WIDTH = 32; // Четверть ширины 128-битного числа.
            constexpr ULOW MASK = (ULOW{1}() << QUORTER_WIDTH) - 1;
            const ULOW x_low = x & MASK;
            const ULOW x_high = x >> QUORTER_WIDTH;
            const ULOW t1 = x_low * x_low;
            const ULOW t = t1 >> QUORTER_WIDTH;
            const ULOW t21 = x_low * x_high;
            const ULOW q = t21 >> QUORTER_WIDTH;
            const ULOW p = t21 & MASK;
            const ULOW t3 = x_high * x_high;
            U128 result{t1};
            const ULOW div = (q << 1) + (((p << 1) + t) >> QUORTER_WIDTH);
            const auto p1 = t21 << QUORTER_WIDTH;
            const ULOW mod = p1 << 1;
            result.mLow += mod;
            result.mHigh += div;
            result.mHigh += t3;
            return result;
#endif
        }

        /**
         * @brief Специальный метод деления на 10 для формирования строкового представления числа.
         */
        U128 div10() const
        {
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_dividend = (static_cast<unsigned __int128>(mHigh()) << 64) | mLow();
            unsigned __int128 u128_divisor = 10ull;
            unsigned __int128 quotient;
            quotient = u128_dividend / u128_divisor;
            return U128{static_cast<u64>(quotient & 0xFFFFFFFFFFFFFFFFULL), static_cast<u64>(quotient >> 64)};
#else
            const U128 &X = *this;
            constexpr auto TEN = ULOW{10};
            const auto &reciprocal = (ULOW::get_max_value() / TEN).first;
            auto [Q, R] = X.high() / TEN;
            ULOW N = R * reciprocal + (X.low() / TEN).first;
            U128 result{N, Q};
            for (U128 E{X - result * TEN}; E >= TEN; E -= TEN * U128{N, Q})
            {
                std::tie(Q, R) = E.mHigh / TEN;
                N = R * reciprocal + (E.mLow / TEN).first;
                result += U128{N, Q};
            }
            return result;
#endif
        }

        /**
         * @brief Специальный метод нахождения остатка от деления на 10 для формирования строкового представления числа.
         */
        int mod10() const
        {
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_dividend = (static_cast<unsigned __int128>(mHigh()) << 64) | mLow();
            unsigned __int128 u128_divisor = 10ull;
            return u128_dividend % u128_divisor;
#else
            const int multiplier_mod10 = ULOW::get_max_value().mod10() + 1;
            return (mLow.mod10() + multiplier_mod10 * mHigh.mod10()) % 10;
#endif
        }

        /**
         * @brief Возвращает строковое представление числа.
         */
        std::string value() const
        {
            std::string result;
            U128 X = *this;
            while (X != U128{0})
            {
                const int d = X.mod10();
                if (d < 0)
                    return result;
                result.push_back(DIGITS[d]);
                X = X.div10();
            }
            std::reverse(result.begin(), result.end());
            return result.length() != 0 ? result : "0";
        }

    private:
        /**
         * @brief Младшая половина числа.
         */
        ULOW mLow{0};

        /**
         * @brief Старшая половина числа.
         */
        ULOW mHigh{0};

        static U128 subtract_if_lhs_more(const U128 &X, const U128 &Y)
        {
            return U128{X.mLow - Y.mLow, X.mHigh - Y.mHigh - (X.mLow < Y.mLow)};
        }

        /**
         * @brief Функция деления двух 128-битных чисел, поддерживается Clang/GCC.
         * @param dividend
         * @param divisor
         * @param remainder_out
         * @return
         */
        template <bool make_quotient = true, bool make_remainder = true>
        static U128 divide_u128(const U128 &dividend, const U128 &divisor, U128 *remainder_out)
        {
#if defined(__SIZEOF_INT128__)
            unsigned __int128 u128_dividend = (static_cast<unsigned __int128>(dividend.mHigh()) << 64) | dividend.mLow();
            unsigned __int128 u128_divisor = (static_cast<unsigned __int128>(divisor.mHigh()) << 64) | divisor.mLow();
            U128 result;
            unsigned __int128 quotient;
            unsigned __int128 remainder;
            if constexpr (make_remainder)
            {
                if constexpr (!make_quotient)
                {
                    remainder = u128_dividend % u128_divisor;
                    remainder_out->mLow = static_cast<u64>(remainder & 0xFFFFFFFFFFFFFFFFULL);
                    remainder_out->mHigh = static_cast<u64>(remainder >> 64);
                }
                if constexpr (make_quotient)
                {
                    quotient = u128_dividend / u128_divisor;
                    remainder = u128_dividend % u128_divisor;
                    result.mLow = static_cast<u64>(quotient & 0xFFFFFFFFFFFFFFFFULL);
                    result.mHigh = static_cast<u64>(quotient >> 64);
                    remainder_out->mLow = static_cast<u64>(remainder & 0xFFFFFFFFFFFFFFFFULL);
                    remainder_out->mHigh = static_cast<u64>(remainder >> 64);
                }
            }
            if constexpr (!make_remainder && make_quotient)
            {
                quotient = u128_dividend / u128_divisor;
                result.mLow = static_cast<u64>(quotient & 0xFFFFFFFFFFFFFFFFULL);
                result.mHigh = static_cast<u64>(quotient >> 64);
            }
            return result;
#elif defined(USE_MSVC_INTRINSICS_DIVISION)
            U128 q = div_u128_full(dividend, divisor, remainder_out);
            return q;
#else
            static_assert(1 == 0 && "Компилятором не поддерживается деление 128-битных чисел.");
#endif
        }
#ifdef USE_MSVC_INTRINSICS_DIVISION
        static U128 div_u128_full(const U128 &dividend, U128 divisor, U128 *remainder)
        {
            if (divisor.mHigh() == 0)
            {
                u64 rem;
                U128 q = div_u128_half(dividend, divisor.mLow(), &rem);
                remainder->mLow() = rem;
                remainder->mHigh() = 0;
                return q;
            }
            const auto cl = divisor.countl_zero();
            divisor <<= cl;
            U128 x_2d{dividend.mHigh()};
            U128 tmp{dividend.mLow()};
            x_2d <<= cl;
            tmp <<= cl;
            x_2d.mLow() |= tmp.mHigh();
            u64 rem;
            u64 q = div_u128_cpu(x_2d, divisor.mHigh(), &rem);
            x_2d.mLow() = tmp.mLow();
            x_2d.mHigh() = rem;
            const U128& T = U128::mult_ext(q, divisor.mLow());
            U128 r {x_2d - T};
            if (x_2d < T)
            {
                r += divisor;
                q -= 1;
            }
            r >>= cl;
            *remainder = r;
            return q;
        }
        static U128 div_u128_half(const U128 &dividend, u64 divisor, u64 *remainder)
        {
            const auto cl = std::countl_zero(divisor);
            divisor <<= cl;
            U128 x_2d{dividend.mHigh()};
            U128 tmp{dividend.mLow()};
            x_2d <<= cl;
            tmp <<= cl;
            x_2d.mLow() |= tmp.mHigh();
            u64 rem;
            u64 q = div_u128_cpu(x_2d, divisor, &rem);
            U128 r{tmp.mLow(), rem};
            u64 q1 = div_u128_cpu(r, divisor, &rem);
            U128 quotient{q1, q};
            rem >>= cl;
            *remainder = rem;
            return quotient;
        }
        static u64 div_u128_cpu(const U128 &dividend, u64 divisor, u64 *remainder)
        {
            unsigned __int64 high = dividend.mHigh();
            unsigned __int64 low = dividend.mLow();
            u64 quotient = _udiv128(high, low, divisor, remainder);
            return quotient;
        }
#endif
    };

}
